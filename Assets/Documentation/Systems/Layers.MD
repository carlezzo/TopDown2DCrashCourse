# Sistema de ElevaÃ§Ã£o Multi-NÃ­veis com Layers

> **Autor:** Engenharia SÃªnior Unity 2D
> **VersÃ£o:** 1.0
> **Data:** 2025-11-13
> **Projeto:** TopDown2D Crash Course

---

## ğŸ“‹ Ãndice

1. [VisÃ£o Geral Conceitual](#1-visÃ£o-geral-conceitual)
2. [Arquitetura TÃ©cnica](#2-arquitetura-tÃ©cnica)
3. [Casos de Uso PrÃ¡ticos](#3-casos-de-uso-prÃ¡ticos)
4. [ImplementaÃ§Ã£o de CÃ³digo](#4-implementaÃ§Ã£o-de-cÃ³digo)
5. [Setup no Unity Editor](#5-setup-no-unity-editor)
6. [RenderizaÃ§Ã£o Complexa](#6-renderizaÃ§Ã£o-complexa)
7. [Edge Cases e SoluÃ§Ãµes](#7-edge-cases-e-soluÃ§Ãµes)
8. [MigraÃ§Ã£o do Sistema Atual](#8-migraÃ§Ã£o-do-sistema-atual)
9. [Performance e OtimizaÃ§Ã£o](#9-performance-e-otimizaÃ§Ã£o)
10. [ReferÃªncias](#10-referÃªncias)

---

## 1. VisÃ£o Geral Conceitual

### 1.1 O Problema

Em jogos 2D top-down com mÃºltiplos nÃ­veis de elevaÃ§Ã£o (montanhas, pontes, plataformas), precisamos resolver **dois problemas distintos**:

1. **ColisÃ£o FÃ­sica:** Entidades em nÃ­veis diferentes nÃ£o devem colidir
2. **OrdenaÃ§Ã£o Visual:** Sprites devem renderizar na ordem correta (profundidade)

### 1.2 DiferenÃ§a Entre Layer Types

Unity 2D possui **dois sistemas de layers independentes**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHYSICS LAYERS (Collision)                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  â€¢ Controlam QUEM colide com QUEM                           â”‚
â”‚  â€¢ Configurados na Collision Matrix (Physics 2D Settings)   â”‚
â”‚  â€¢ MÃ¡ximo: 32 layers (0-31)                                 â”‚
â”‚  â€¢ Usado por: Collider2D, Rigidbody2D, ContactFilter2D     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SORTING LAYERS (Rendering)                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  â€¢ Controlam ORDEM de renderizaÃ§Ã£o (o que fica na frente)   â”‚
â”‚  â€¢ Configurados no TagManager                               â”‚
â”‚  â€¢ Ilimitados (crie quantos precisar)                       â”‚
â”‚  â€¢ Usado por: SpriteRenderer, TilemapRenderer               â”‚
â”‚  â€¢ Sorting Order (int) dentro de cada Sorting Layer         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 Conceito: 4 NÃ­veis de ElevaÃ§Ã£o

Exemplo baseado na sua imagem do morro:

```
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  NÃVEL 3: ROOFTOP (Telhado)           â”‚ â† Mais alto
         â”‚  Physics Layer: 9                      â”‚
         â”‚  Sorting Layer: Level3                 â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â–²
                    [ESCADA]
                        â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  NÃVEL 2: BRIDGE (Ponte/Plataforma)    â”‚
         â”‚  Physics Layer: 8                      â”‚
         â”‚  Sorting Layer: Level2                 â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â–²
                    [ESCADA]
                        â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  NÃVEL 1: PLATFORM (Montanha Base)     â”‚
         â”‚  Physics Layer: 7                      â”‚
         â”‚  Sorting Layer: Level1                 â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â–²
                    [ESCADA]
                        â”‚
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â•‘  NÃVEL 0: GROUND (ChÃ£o)                       â•‘ â† Mais baixo
    â•‘  Physics Layer: 6                             â•‘
    â•‘  Sorting Layer: Level0                        â•‘
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### 1.4 Vantagens Sobre Sistema Atual

**Sistema Atual (ElevationEntry.cs):**
```csharp
// âŒ Problemas:
- Desabilita colliders manualmente (custoso)
- NÃ£o funciona para mÃºltiplas entidades
- Unidirecional (sem exit logic)
- Hardcoded sorting order
- NÃ£o escalÃ¡vel (sÃ³ 2 nÃ­veis)
```

**Sistema com Layers:**
```csharp
// âœ… Vantagens:
- Unity gerencia colisÃµes automaticamente via Matrix
- Funciona para Player, Enemies, NPCs, Projectiles
- Bidirecional por design
- Sorting layers configurÃ¡veis
- EscalÃ¡vel (4+ nÃ­veis facilmente)
- PerformÃ¡tico (sem enable/disable de colliders)
- State management integrado
```

---

## 2. Arquitetura TÃ©cnica

### 2.1 Physics Layers (ColisÃ£o)

**EstratÃ©gia de Camadas:**

```csharp
// Layers 0-5: Reservados pelo Unity/Projeto
// Layers 6-9: Sistema de ElevaÃ§Ã£o

Layer 6  â†’ "ElevationLevel0" (Ground)
Layer 7  â†’ "ElevationLevel1" (Platform/Montanha)
Layer 8  â†’ "ElevationLevel2" (Bridge)
Layer 9  â†’ "ElevationLevel3" (Rooftop)

// Layers 10-31: DisponÃ­veis para expansÃ£o futura
```

### 2.2 Collision Matrix

**Tabela de InteraÃ§Ãµes (quem colide com quem):**

| Layer          | Level0 | Level1 | Level2 | Level3 | Default | Enemy | Player |
|----------------|--------|--------|--------|--------|---------|-------|--------|
| **Level0**     | âœ…     | âŒ     | âŒ     | âŒ     | âœ…      | âœ…    | âœ…     |
| **Level1**     | âŒ     | âœ…     | âŒ     | âŒ     | âœ…      | âœ…    | âœ…     |
| **Level2**     | âŒ     | âŒ     | âœ…     | âŒ     | âœ…      | âœ…    | âœ…     |
| **Level3**     | âŒ     | âŒ     | âŒ     | âœ…     | âœ…      | âœ…    | âœ…     |
| **Default**    | âœ…     | âœ…     | âœ…     | âœ…     | âœ…      | âœ…    | âœ…     |

**LÃ³gica:**
- âœ… = Colide (entidades no mesmo nÃ­vel interagem)
- âŒ = NÃ£o colide (entidades em nÃ­veis diferentes passam atravÃ©s)
- Default layer colide com tudo (items, decoraÃ§Ã£o genÃ©rica)

### 2.3 Sorting Layers (RenderizaÃ§Ã£o)

**Hierarquia Visual (ordem de renderizaÃ§Ã£o):**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Background      â†’ -100 a -1   (cÃ©u, nuvens)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. Level0Ground    â†’ 0 a 999     (chÃ£o base)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3. Level0Entities  â†’ 1000 a 1999 (player/enemies chÃ£o)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4. Level1Ground    â†’ 2000 a 2999 (montanha tiles)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 5. Level1Entities  â†’ 3000 a 3999 (entities montanha)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 6. Level2Ground    â†’ 4000 a 4999 (ponte tiles)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 7. Level2Entities  â†’ 5000 a 5999 (entities ponte)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 8. Level3Ground    â†’ 6000 a 6999 (telhado tiles)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 9. Level3Entities  â†’ 7000 a 7999 (entities telhado)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 10. Foreground     â†’ 8000+       (UI, efeitos)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Nota Importante:** Cada Sorting Layer tem um range de 1000 sorting orders para permitir **Y-Sorting** dentro do mesmo nÃ­vel.

### 2.4 Y-Sorting (Profundidade DinÃ¢mica)

Em top-down 2D, entidades mais ao **norte** (Y maior) devem renderizar **atrÃ¡s** de entidades ao **sul** (Y menor):

```
       NORTE (Y alto)
           â–²
           â”‚
    ğŸ§™ [Y=10] â† Renderiza ATRÃS
           â”‚
    ğŸ—¡ï¸ [Y=5]  â† Renderiza NA FRENTE
           â”‚
           â–¼
       SUL (Y baixo)
```

**FÃ³rmula de Sorting Order:**

```csharp
// Para entidades no Level1 (range 3000-3999):
int baseSortingOrder = 3000;  // Base do Level1Entities
float yPosition = transform.position.y;

// Normalizar Y para o range [0-999]
int sortingOrder = baseSortingOrder + (int)(999 - (yPosition * 10));
```

**Resultado:**
- Y=10 â†’ sortingOrder = 3000 + (999 - 100) = **3899** (atrÃ¡s)
- Y=5  â†’ sortingOrder = 3000 + (999 - 50)  = **3949** (frente)

---

## 3. Casos de Uso PrÃ¡ticos

### 3.1 Caso 1: Player Subindo Escada

**CenÃ¡rio:** Player no chÃ£o (Level0) entra em trigger de escada para subir montanha (Level1)

```
ANTES:                          DEPOIS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MONTANHA     â”‚                â”‚ MONTANHA     â”‚
â”‚ (Level1)     â”‚                â”‚    ğŸ—¡ï¸       â”‚ â† Player agora aqui
â”‚   âš”ï¸ Enemy   â”‚                â”‚    âš”ï¸ Enemy â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     [ESCADA] â† Trigger              [ESCADA]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ—¡ï¸ Player
  (Level0)                        (Vazio)
```

**O que acontece:**
1. Player entra no trigger da escada
2. `ElevationZone.cs` detecta entrada
3. Muda `player.gameObject.layer` de 6 (Level0) â†’ 7 (Level1)
4. Muda `SpriteRenderer.sortingLayerName` de "Level0Entities" â†’ "Level1Entities"
5. Atualiza sorting order com Y-sorting
6. Player agora colide com paredes Level1, nÃ£o colide com Level0

### 3.2 Caso 2: Inimigo em NÃ­vel Diferente

**CenÃ¡rio:** Enemy no Level1, Player no Level0

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MONTANHA (Level1)        â”‚
â”‚                          â”‚
â”‚   âš”ï¸ Enemy               â”‚ â† NÃ£o detecta player
â”‚   Detection Radius: 5    â”‚    (elevaÃ§Ã£o diferente)
â”‚                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       [ESCADA]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     ğŸ—¡ï¸ Player (Level0)
```

**CÃ³digo do Enemy (MODIFICADO):**

```csharp
// Enemy.cs - DetectPlayer() com Elevation Awareness
private bool CanDetectPlayer()
{
    if (playerTransform == null) return false;

    // âœ… NOVA VERIFICAÃ‡ÃƒO: Mesma elevaÃ§Ã£o?
    int enemyLayer = gameObject.layer;
    int playerLayer = playerTransform.gameObject.layer;

    if (enemyLayer != playerLayer)
    {
        // Entidades em nÃ­veis diferentes nÃ£o interagem
        return false;
    }

    float distanceToPlayer = Vector2.Distance(
        transform.position,
        playerTransform.position
    );

    return distanceToPlayer <= detectionRadius;
}
```

**Resultado:**
- âŒ Enemy nÃ£o persegue player (layers diferentes)
- âœ… ColisÃ£o automÃ¡tica desabilitada (Collision Matrix)
- âœ… Performance otimizada (menos cÃ¡lculos desnecessÃ¡rios)

### 3.3 Caso 3: Player NA FRENTE de Parede (VisÃ­vel, Sem ColisÃ£o)

**Desafio:** Player deve aparecer na frente da parede da montanha, mas nÃ£o atravessÃ¡-la quando estiver no nÃ­vel superior.

```
Vista Lateral (conceitual):        Vista Top-Down (gameplay):

   [TOPO MONTANHA - Level1]            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         ğŸ—¡ï¸ â† Player aqui              â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚ â† Parede
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                 â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚
         â”‚ Parede                       â”‚     ğŸ—¡ï¸     â”‚ â† Player visÃ­vel
         â”‚ (visual)                     â”‚             â”‚    mas nÃ£o colide
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   [CHÃƒO - Level0]
```

**SoluÃ§Ã£o: MÃºltiplos Colliders**

Cada parede/estrutura tem **2 componentes**:

1. **Collider de ColisÃ£o (pequeno):**
   ```csharp
   BoxCollider2D physicsCollider;
   physicsCollider.size = new Vector2(1f, 0.5f);  // Fino
   physicsCollider.offset = new Vector2(0, 0.25f); // Topo
   physicsCollider.gameObject.layer = 7; // Level1
   ```

2. **Sprite Renderizado (completo):**
   ```csharp
   SpriteRenderer wallSprite;
   wallSprite.sortingLayerName = "Level1Ground";
   wallSprite.sortingOrder = 2500; // AtrÃ¡s de entities
   ```

**Diagrama de ImplementaÃ§Ã£o:**

```
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     â”‚ â† SpriteRenderer (visual completo)
    â”‚   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     â”‚
    â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚ â† BoxCollider2D (sÃ³ no topo)
    â”‚                     â”‚
    â”‚        ğŸ—¡ï¸          â”‚ â† Player (Level1)
    â”‚                     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Resultado:
âœ… Player renderiza NA FRENTE do sprite da parede (sorting order)
âŒ Player NÃƒO atravessa parede (collider no topo bloqueia)
```

### 3.4 Caso 4: Player ATRÃS de Montanha (Escondido Desde o Primeiro Tile)

**Desafio:** Quando player passa por trÃ¡s da montanha, ele deve ficar escondido **imediatamente**, nÃ£o apenas quando sobe.

```
Vista Top-Down:

ANTES (problema):                 DEPOIS (soluÃ§Ã£o):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MONTANHA     â”‚                  â”‚ MONTANHA     â”‚
â”‚              â”‚                  â”‚              â”‚
â”‚  ğŸ—¡ï¸ VisÃ­vel â”‚ â† ERRADO          â”‚   [oculto]  â”‚ â† CORRETO
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â–²                                  â–²
     â”‚ Player no Level0                 â”‚ Player no Level0
```

**SoluÃ§Ã£o: Sorting Order Baseado em PosiÃ§Ã£o**

```csharp
// A montanha tem DOIS sorting orders possÃ­veis:
// 1. Base (para player passar por trÃ¡s)
// 2. Frente (para player passar na frente)

// Montanha GameObject:
public class MountainDepthSorter : MonoBehaviour
{
    [SerializeField] private SpriteRenderer mountainSprite;
    [SerializeField] private float pivotY = 5f; // Y onde montanha "comeÃ§a"

    private const int BEHIND_ORDER = 1500;  // Level0Entities base
    private const int FRONT_ORDER = 2500;   // Level1Ground base

    void Update()
    {
        // Verifica se hÃ¡ players/entities no Level0 prÃ³ximos
        Collider2D[] nearbyEntities = Physics2D.OverlapCircleAll(
            transform.position,
            3f,
            LayerMask.GetMask("ElevationLevel0")
        );

        foreach (var entity in nearbyEntities)
        {
            float entityY = entity.transform.position.y;

            // Se entity estÃ¡ ATRÃS (Y menor que pivot da montanha)
            if (entityY < pivotY)
            {
                // Montanha renderiza NA FRENTE (esconde entity)
                mountainSprite.sortingLayerName = "Level0Entities";
                mountainSprite.sortingOrder = 1900; // Alto no range
            }
            else
            {
                // Entity estÃ¡ na frente da montanha
                mountainSprite.sortingLayerName = "Level1Ground";
                mountainSprite.sortingOrder = 2500;
            }
        }
    }
}
```

**Alternativa Mais PerformÃ¡tica: Zones de OclusÃ£o**

```csharp
// Criar um trigger invisÃ­vel atrÃ¡s da montanha:
public class OcclusionZone : MonoBehaviour
{
    [SerializeField] private int occludedSortingOrder = 1900;
    private Dictionary<SpriteRenderer, int> originalOrders = new();

    void OnTriggerEnter2D(Collider2D collision)
    {
        if (!collision.CompareTag("Player")) return;

        var sr = collision.GetComponent<SpriteRenderer>();
        if (sr != null)
        {
            originalOrders[sr] = sr.sortingOrder;
            sr.sortingOrder = occludedSortingOrder; // Por trÃ¡s
        }
    }

    void OnTriggerExit2D(Collider2D collision)
    {
        if (!collision.CompareTag("Player")) return;

        var sr = collision.GetComponent<SpriteRenderer>();
        if (sr != null && originalOrders.ContainsKey(sr))
        {
            sr.sortingOrder = originalOrders[sr]; // Restaura
            originalOrders.Remove(sr);
        }
    }
}
```

### 3.5 Caso 5: Quatro NÃ­veis SimultÃ¢neos

**CenÃ¡rio:** Complexo com chÃ£o (0), plataforma (1), ponte (2), e telhado (3)

```
VISUALIZAÃ‡ÃƒO 3D CONCEITUAL:

        [TELHADO - Level3]  â† Topo da torre
             ğŸ§™ Mago
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              ğŸªœ
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        [PONTE - Level2]    â† Passarela
             âš”ï¸ Guard
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              ğŸªœ
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        [PLATAFORMA - Level1] â† Montanha
             ğŸº Wolf
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              ğŸªœ
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ [CHÃƒO - Level0]           â•‘
â•‘    ğŸ—¡ï¸ Player              â•‘
â•‘                            â•‘
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

REGRAS:
â€¢ Mago (Level3) nÃ£o detecta player (Level0)
â€¢ Guard (Level2) nÃ£o colide com Wolf (Level1)
â€¢ Player pode ver todos os nÃ­veis (camera rendering)
â€¢ Cada nÃ­vel tem suas prÃ³prias escadas
```

**ImplementaÃ§Ã£o:**

```csharp
// ElevationManager.cs - Sistema centralizado
public class ElevationManager : MonoBehaviour
{
    public static ElevationManager Instance { get; private set; }

    public enum ElevationLevel
    {
        Ground = 0,    // Layer 6
        Platform = 1,  // Layer 7
        Bridge = 2,    // Layer 8
        Rooftop = 3    // Layer 9
    }

    // Mapeamento de layers
    private static readonly Dictionary<ElevationLevel, int> LayerMap = new()
    {
        { ElevationLevel.Ground, 6 },
        { ElevationLevel.Platform, 7 },
        { ElevationLevel.Bridge, 8 },
        { ElevationLevel.Rooftop, 9 }
    };

    // Sorting layers por nÃ­vel
    private static readonly Dictionary<ElevationLevel, string> SortingLayerMap = new()
    {
        { ElevationLevel.Ground, "Level0Entities" },
        { ElevationLevel.Platform, "Level1Entities" },
        { ElevationLevel.Bridge, "Level2Entities" },
        { ElevationLevel.Rooftop, "Level3Entities" }
    };

    // Ranges de sorting order
    private static readonly Dictionary<ElevationLevel, int> BaseSortingOrder = new()
    {
        { ElevationLevel.Ground, 1000 },
        { ElevationLevel.Platform, 3000 },
        { ElevationLevel.Bridge, 5000 },
        { ElevationLevel.Rooftop, 7000 }
    };

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    // API pÃºblica para mudanÃ§a de elevaÃ§Ã£o
    public static void SetEntityElevation(GameObject entity, ElevationLevel level)
    {
        if (entity == null) return;

        // 1. Mudar Physics Layer (colisÃ£o)
        entity.layer = LayerMap[level];

        // 2. Mudar Sorting Layer (renderizaÃ§Ã£o)
        var spriteRenderer = entity.GetComponent<SpriteRenderer>();
        if (spriteRenderer != null)
        {
            spriteRenderer.sortingLayerName = SortingLayerMap[level];

            // 3. Aplicar Y-sorting dentro do nÃ­vel
            UpdateYSorting(entity, level);
        }

        // 4. Disparar evento
        OnElevationChanged?.Invoke(entity, level);
    }

    private static void UpdateYSorting(GameObject entity, ElevationLevel level)
    {
        var spriteRenderer = entity.GetComponent<SpriteRenderer>();
        if (spriteRenderer == null) return;

        int baseOrder = BaseSortingOrder[level];
        float yPos = entity.transform.position.y;

        // Normalizar Y para range [0-999]
        // Assumindo mundo de 0 a 100 unidades em Y
        int yOffset = Mathf.Clamp((int)((100 - yPos) * 10), 0, 999);

        spriteRenderer.sortingOrder = baseOrder + yOffset;
    }

    // Eventos
    public static event System.Action<GameObject, ElevationLevel> OnElevationChanged;

    // Utility: Checar se duas entidades estÃ£o no mesmo nÃ­vel
    public static bool AreOnSameLevel(GameObject a, GameObject b)
    {
        return a.layer == b.layer;
    }

    // Utility: Obter nÃ­vel atual de uma entidade
    public static ElevationLevel GetEntityLevel(GameObject entity)
    {
        int layer = entity.layer;

        foreach (var kvp in LayerMap)
        {
            if (kvp.Value == layer)
                return kvp.Key;
        }

        return ElevationLevel.Ground; // Default
    }
}
```

---

## 4. ImplementaÃ§Ã£o de CÃ³digo

### 4.1 ElevationZone.cs (Triggers de Escada)

```csharp
using UnityEngine;

/// <summary>
/// Componente para triggers de transiÃ§Ã£o entre nÃ­veis (escadas, portais, etc).
/// Substitui ElevationEntry.cs com suporte bidirecional e multi-entity.
/// </summary>
[RequireComponent(typeof(Collider2D))]
public class ElevationZone : MonoBehaviour
{
    [Header("ConfiguraÃ§Ã£o de ElevaÃ§Ã£o")]
    [Tooltip("NÃ­vel de destino ao entrar neste trigger")]
    [SerializeField] private ElevationManager.ElevationLevel targetLevel = ElevationManager.ElevationLevel.Platform;

    [Tooltip("NÃ­vel de origem esperado (opcional, deixe -1 para aceitar qualquer)")]
    [SerializeField] private int requiredSourceLevel = -1;

    [Header("ConfiguraÃ§Ã£o de TransiÃ§Ã£o")]
    [Tooltip("DireÃ§Ã£o da transiÃ§Ã£o (para UI/feedback)")]
    [SerializeField] private TransitionDirection direction = TransitionDirection.Up;

    [Tooltip("Tempo de cooldown apÃ³s transiÃ§Ã£o (evita re-trigger)")]
    [SerializeField] private float transitionCooldown = 0.5f;

    [Header("Efeitos (Opcional)")]
    [SerializeField] private AudioClip transitionSound;
    [SerializeField] private GameObject transitionVFX;

    [Header("Debug")]
    [SerializeField] private bool showDebugGizmos = true;

    private Collider2D triggerCollider;
    private AudioSource audioSource;
    private float lastTransitionTime;

    public enum TransitionDirection
    {
        Up,
        Down,
        Bidirectional
    }

    void Awake()
    {
        triggerCollider = GetComponent<Collider2D>();

        if (!triggerCollider.isTrigger)
        {
            Debug.LogWarning($"[ElevationZone] Collider em {gameObject.name} nÃ£o estÃ¡ como Trigger! Corrigindo...");
            triggerCollider.isTrigger = true;
        }

        // Setup opcional de Ã¡udio
        audioSource = GetComponent<AudioSource>();
        if (audioSource == null && transitionSound != null)
        {
            audioSource = gameObject.AddComponent<AudioSource>();
            audioSource.playOnAwake = false;
        }
    }

    void OnTriggerEnter2D(Collider2D collision)
    {
        // Cooldown para evitar mÃºltiplas transiÃ§Ãµes
        if (Time.time - lastTransitionTime < transitionCooldown)
            return;

        // Verificar se Ã© uma entidade vÃ¡lida (Player, Enemy, NPC)
        if (!IsValidEntity(collision.gameObject))
            return;

        // Verificar nÃ­vel de origem (se especificado)
        if (requiredSourceLevel >= 0)
        {
            var currentLevel = ElevationManager.GetEntityLevel(collision.gameObject);
            if ((int)currentLevel != requiredSourceLevel)
            {
                Debug.Log($"[ElevationZone] {collision.name} nÃ£o estÃ¡ no nÃ­vel correto. Esperado: {requiredSourceLevel}, Atual: {currentLevel}");
                return;
            }
        }

        // Executar transiÃ§Ã£o
        PerformTransition(collision.gameObject);

        lastTransitionTime = Time.time;
    }

    private void PerformTransition(GameObject entity)
    {
        // Obter nÃ­vel anterior para eventos
        var previousLevel = ElevationManager.GetEntityLevel(entity);

        // Mudar elevaÃ§Ã£o via manager
        ElevationManager.SetEntityElevation(entity, targetLevel);

        // Feedback visual
        if (transitionVFX != null)
        {
            Instantiate(transitionVFX, entity.transform.position, Quaternion.identity);
        }

        // Feedback sonoro
        if (audioSource != null && transitionSound != null)
        {
            audioSource.PlayOneShot(transitionSound);
        }

        // Log para debug
        Debug.Log($"[ElevationZone] {entity.name} transitou: {previousLevel} â†’ {targetLevel}");

        // Notificar componente da entidade (se existir)
        var elevationEntity = entity.GetComponent<ElevationEntity>();
        elevationEntity?.OnElevationTransition(previousLevel, targetLevel);
    }

    private bool IsValidEntity(GameObject obj)
    {
        // Verificar tags vÃ¡lidas
        if (obj.CompareTag("Player") || obj.CompareTag("Enemy"))
            return true;

        // Ou verificar se tem componente ElevationEntity
        return obj.GetComponent<ElevationEntity>() != null;
    }

    void OnDrawGizmos()
    {
        if (!showDebugGizmos) return;

        Gizmos.color = direction switch
        {
            TransitionDirection.Up => Color.green,
            TransitionDirection.Down => Color.red,
            TransitionDirection.Bidirectional => Color.yellow,
            _ => Color.white
        };

        var collider = GetComponent<Collider2D>();
        if (collider != null)
        {
            Gizmos.DrawWireCube(transform.position, collider.bounds.size);
        }
    }

    void OnDrawGizmosSelected()
    {
        if (!showDebugGizmos) return;

        // Desenhar seta indicando direÃ§Ã£o
        Vector3 arrowStart = transform.position;
        Vector3 arrowEnd = direction switch
        {
            TransitionDirection.Up => arrowStart + Vector3.up * 2,
            TransitionDirection.Down => arrowStart + Vector3.down * 2,
            _ => arrowStart
        };

        Gizmos.color = Color.cyan;
        Gizmos.DrawLine(arrowStart, arrowEnd);

        // Label com info
        #if UNITY_EDITOR
        UnityEditor.Handles.Label(
            transform.position + Vector3.up * 0.5f,
            $"â†’ Level {(int)targetLevel}\n({targetLevel})"
        );
        #endif
    }
}
```

### 4.2 ElevationEntity.cs (Componente para Entidades)

```csharp
using UnityEngine;

/// <summary>
/// Componente que deve ser adicionado a todas as entidades que podem mudar de elevaÃ§Ã£o
/// (Player, Enemies, NPCs). Gerencia estado e Y-sorting automÃ¡tico.
/// </summary>
[RequireComponent(typeof(SpriteRenderer))]
public class ElevationEntity : MonoBehaviour
{
    [Header("ConfiguraÃ§Ã£o Inicial")]
    [SerializeField] private ElevationManager.ElevationLevel startingLevel = ElevationManager.ElevationLevel.Ground;

    [Header("Y-Sorting")]
    [Tooltip("Atualizar sorting order baseado em posiÃ§Ã£o Y?")]
    [SerializeField] private bool enableYSorting = true;

    [Tooltip("Offset adicional ao sorting order")]
    [SerializeField] private int sortingOrderOffset = 0;

    [Header("Debug")]
    [SerializeField] private bool showDebugInfo = false;

    // Cache de componentes
    private SpriteRenderer spriteRenderer;
    private ElevationManager.ElevationLevel currentLevel;

    // Propriedade pÃºblica
    public ElevationManager.ElevationLevel CurrentLevel => currentLevel;

    void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();

        if (spriteRenderer == null)
        {
            Debug.LogError($"[ElevationEntity] {gameObject.name} precisa de SpriteRenderer!");
            enabled = false;
            return;
        }

        // Configurar elevaÃ§Ã£o inicial
        SetElevation(startingLevel);
    }

    void Update()
    {
        if (enableYSorting)
        {
            UpdateYSorting();
        }
    }

    /// <summary>
    /// Muda a elevaÃ§Ã£o desta entidade
    /// </summary>
    public void SetElevation(ElevationManager.ElevationLevel newLevel)
    {
        currentLevel = newLevel;
        ElevationManager.SetEntityElevation(gameObject, newLevel);

        if (showDebugInfo)
        {
            Debug.Log($"[ElevationEntity] {gameObject.name} agora estÃ¡ em {newLevel}");
        }
    }

    /// <summary>
    /// Callback chamado por ElevationZone quando hÃ¡ transiÃ§Ã£o
    /// </summary>
    public void OnElevationTransition(
        ElevationManager.ElevationLevel from,
        ElevationManager.ElevationLevel to
    )
    {
        currentLevel = to;

        if (showDebugInfo)
        {
            Debug.Log($"[ElevationEntity] {gameObject.name} transitou: {from} â†’ {to}");
        }

        // Aqui vocÃª pode adicionar lÃ³gica customizada:
        // - Mudar velocidade de movimento
        // - Trocar animaÃ§Ãµes
        // - Emitir partÃ­culas
        // - Tocar som de passos diferentes
    }

    /// <summary>
    /// Atualiza sorting order baseado em posiÃ§Ã£o Y
    /// </summary>
    private void UpdateYSorting()
    {
        if (spriteRenderer == null) return;

        // Obter base sorting order do nÃ­vel atual
        int baseSortingOrder = currentLevel switch
        {
            ElevationManager.ElevationLevel.Ground => 1000,
            ElevationManager.ElevationLevel.Platform => 3000,
            ElevationManager.ElevationLevel.Bridge => 5000,
            ElevationManager.ElevationLevel.Rooftop => 7000,
            _ => 0
        };

        // Calcular offset baseado em Y
        // Assumindo mundo de -50 a +50 em Y
        float yPos = transform.position.y;
        int yOffset = Mathf.Clamp((int)((50 - yPos) * 10), 0, 999);

        // Aplicar sorting order
        spriteRenderer.sortingOrder = baseSortingOrder + yOffset + sortingOrderOffset;
    }

    /// <summary>
    /// Verifica se esta entidade estÃ¡ no mesmo nÃ­vel que outra
    /// </summary>
    public bool IsOnSameLevelAs(GameObject other)
    {
        var otherEntity = other.GetComponent<ElevationEntity>();
        if (otherEntity != null)
        {
            return currentLevel == otherEntity.currentLevel;
        }

        // Fallback: comparar layers diretamente
        return gameObject.layer == other.layer;
    }

    /// <summary>
    /// Verifica se esta entidade pode interagir com outra (mesmo nÃ­vel)
    /// </summary>
    public bool CanInteractWith(GameObject other)
    {
        return IsOnSameLevelAs(other);
    }

    void OnDrawGizmosSelected()
    {
        if (!showDebugInfo) return;

        // Desenhar esfera colorida indicando nÃ­vel
        Color levelColor = currentLevel switch
        {
            ElevationManager.ElevationLevel.Ground => Color.green,
            ElevationManager.ElevationLevel.Platform => Color.yellow,
            ElevationManager.ElevationLevel.Bridge => Color.cyan,
            ElevationManager.ElevationLevel.Rooftop => Color.magenta,
            _ => Color.white
        };

        Gizmos.color = levelColor;
        Gizmos.DrawWireSphere(transform.position, 0.5f);

        #if UNITY_EDITOR
        UnityEditor.Handles.Label(
            transform.position + Vector3.up,
            $"Level: {currentLevel} ({(int)currentLevel})\nLayer: {gameObject.layer}"
        );
        #endif
    }
}
```

### 4.3 IntegraÃ§Ã£o com PlayerController

```csharp
// Adicionar ao PlayerController.cs existente:

public class PlayerController : MonoBehaviour
{
    // ... cÃ³digo existente ...

    private ElevationEntity elevationEntity; // NOVO

    void Awake()
    {
        // ... cÃ³digo existente ...

        // ADICIONAR:
        elevationEntity = GetComponent<ElevationEntity>();
        if (elevationEntity == null)
        {
            elevationEntity = gameObject.AddComponent<ElevationEntity>();
            Debug.LogWarning("[PlayerController] ElevationEntity adicionado automaticamente.");
        }
    }

    // ... resto do cÃ³digo ...
}
```

### 4.4 IntegraÃ§Ã£o com Enemy.cs

```csharp
// Modificar Enemy.cs existente:

public class Enemy : MonoBehaviour
{
    // ... cÃ³digo existente ...

    private ElevationEntity elevationEntity; // NOVO

    void Awake()
    {
        // ... cÃ³digo existente ...

        // ADICIONAR:
        elevationEntity = GetComponent<ElevationEntity>();
        if (elevationEntity == null)
        {
            elevationEntity = gameObject.AddComponent<ElevationEntity>();
        }
    }

    // MODIFICAR mÃ©todo de detecÃ§Ã£o:
    private bool CanDetectPlayer()
    {
        if (playerTransform == null) return false;

        // âœ… VERIFICAÃ‡ÃƒO DE ELEVAÃ‡ÃƒO
        if (elevationEntity != null && !elevationEntity.CanInteractWith(playerTransform.gameObject))
        {
            return false; // NÃ­veis diferentes, nÃ£o detecta
        }

        float distanceToPlayer = Vector2.Distance(
            transform.position,
            playerTransform.position
        );

        return distanceToPlayer <= detectionRadius;
    }

    // ... resto do cÃ³digo ...
}
```

### 4.5 ElevationHelper.cs (UtilitÃ¡rios)

```csharp
using UnityEngine;

/// <summary>
/// Classe estÃ¡tica com mÃ©todos utilitÃ¡rios para o sistema de elevaÃ§Ã£o
/// </summary>
public static class ElevationHelper
{
    // Nomes dos layers (match com ProjectSettings)
    public const string LAYER_LEVEL0 = "ElevationLevel0";
    public const string LAYER_LEVEL1 = "ElevationLevel1";
    public const string LAYER_LEVEL2 = "ElevationLevel2";
    public const string LAYER_LEVEL3 = "ElevationLevel3";

    // IDs dos layers
    public const int LAYER_ID_LEVEL0 = 6;
    public const int LAYER_ID_LEVEL1 = 7;
    public const int LAYER_ID_LEVEL2 = 8;
    public const int LAYER_ID_LEVEL3 = 9;

    /// <summary>
    /// Converte layer ID para ElevationLevel enum
    /// </summary>
    public static ElevationManager.ElevationLevel LayerToLevel(int layerID)
    {
        return layerID switch
        {
            LAYER_ID_LEVEL0 => ElevationManager.ElevationLevel.Ground,
            LAYER_ID_LEVEL1 => ElevationManager.ElevationLevel.Platform,
            LAYER_ID_LEVEL2 => ElevationManager.ElevationLevel.Bridge,
            LAYER_ID_LEVEL3 => ElevationManager.ElevationLevel.Rooftop,
            _ => ElevationManager.ElevationLevel.Ground
        };
    }

    /// <summary>
    /// Converte ElevationLevel enum para layer ID
    /// </summary>
    public static int LevelToLayer(ElevationManager.ElevationLevel level)
    {
        return level switch
        {
            ElevationManager.ElevationLevel.Ground => LAYER_ID_LEVEL0,
            ElevationManager.ElevationLevel.Platform => LAYER_ID_LEVEL1,
            ElevationManager.ElevationLevel.Bridge => LAYER_ID_LEVEL2,
            ElevationManager.ElevationLevel.Rooftop => LAYER_ID_LEVEL3,
            _ => LAYER_ID_LEVEL0
        };
    }

    /// <summary>
    /// ObtÃ©m LayerMask para um nÃ­vel especÃ­fico
    /// </summary>
    public static LayerMask GetLayerMask(ElevationManager.ElevationLevel level)
    {
        int layerID = LevelToLayer(level);
        return LayerMask.GetMask(LayerMask.LayerToName(layerID));
    }

    /// <summary>
    /// Verifica se dois GameObjects estÃ£o no mesmo nÃ­vel de elevaÃ§Ã£o
    /// </summary>
    public static bool AreOnSameLevel(GameObject a, GameObject b)
    {
        if (a == null || b == null) return false;
        return a.layer == b.layer;
    }

    /// <summary>
    /// ObtÃ©m todas as entidades em um nÃ­vel especÃ­fico
    /// </summary>
    public static GameObject[] GetEntitiesAtLevel(ElevationManager.ElevationLevel level)
    {
        int layerID = LevelToLayer(level);
        var allObjects = Object.FindObjectsByType<GameObject>(FindObjectsSortMode.None);

        return System.Array.FindAll(allObjects, obj => obj.layer == layerID);
    }

    /// <summary>
    /// Debug: Imprime informaÃ§Ãµes de elevaÃ§Ã£o de um GameObject
    /// </summary>
    public static void DebugElevationInfo(GameObject obj)
    {
        if (obj == null) return;

        int layer = obj.layer;
        string layerName = LayerMask.LayerToName(layer);
        var level = LayerToLevel(layer);
        var elevationEntity = obj.GetComponent<ElevationEntity>();

        Debug.Log($"[ElevationHelper] {obj.name}:\n" +
                  $"  Layer ID: {layer}\n" +
                  $"  Layer Name: {layerName}\n" +
                  $"  Elevation Level: {level}\n" +
                  $"  Has ElevationEntity: {elevationEntity != null}");
    }
}
```

---

## 5. Setup no Unity Editor

### 5.1 Configurar Physics Layers

**Caminho:** `Edit â†’ Project Settings â†’ Tags and Layers`

**AÃ§Ãµes:**
1. Scroll atÃ© "Layers"
2. Configure os seguintes layers:
   ```
   Layer 6: ElevationLevel0
   Layer 7: ElevationLevel1
   Layer 8: ElevationLevel2
   Layer 9: ElevationLevel3
   ```

**Screenshot conceitual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Tags and Layers                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Layers                          â”‚
â”‚                                 â”‚
â”‚ [0] Default                     â”‚
â”‚ [1] TransparentFX               â”‚
â”‚ [2] Ignore Raycast              â”‚
â”‚ [3] (empty)                     â”‚
â”‚ [4] Water                       â”‚
â”‚ [5] UI                          â”‚
â”‚ [6] ElevationLevel0      â† ADD  â”‚
â”‚ [7] ElevationLevel1      â† ADD  â”‚
â”‚ [8] ElevationLevel2      â† ADD  â”‚
â”‚ [9] ElevationLevel3      â† ADD  â”‚
â”‚ ...                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 Configurar Sorting Layers

**Caminho:** `Edit â†’ Project Settings â†’ Tags and Layers`

**AÃ§Ãµes:**
1. Scroll atÃ© "Sorting Layers"
2. Clique no "+" para adicionar as seguintes layers **na ordem**:
   ```
   1. Background        (ID: auto)
   2. Level0Ground      (ID: auto)
   3. Level0Entities    (ID: auto)
   4. Level1Ground      (ID: auto)
   5. Level1Entities    (ID: auto)
   6. Level2Ground      (ID: auto)
   7. Level2Entities    (ID: auto)
   8. Level3Ground      (ID: auto)
   9. Level3Entities    (ID: auto)
   10. Foreground       (ID: auto)
   ```

**IMPORTANTE:** A ordem importa! Layers no topo renderizam primeiro (atrÃ¡s).

### 5.3 Configurar Collision Matrix

**Caminho:** `Edit â†’ Project Settings â†’ Physics 2D`

**AÃ§Ãµes:**
1. Scroll atÃ© "Layer Collision Matrix"
2. Configure conforme a tabela:

```
DESMARQUE os checkboxes para DESABILITAR colisÃ£o entre:
- ElevationLevel0 â†” ElevationLevel1
- ElevationLevel0 â†” ElevationLevel2
- ElevationLevel0 â†” ElevationLevel3
- ElevationLevel1 â†” ElevationLevel2
- ElevationLevel1 â†” ElevationLevel3
- ElevationLevel2 â†” ElevationLevel3

MANTENHA MARCADO (colisÃ£o habilitada):
- ElevationLevel0 â†” ElevationLevel0 (mesmo nÃ­vel)
- ElevationLevel1 â†” ElevationLevel1 (mesmo nÃ­vel)
- ElevationLevel2 â†” ElevationLevel2 (mesmo nÃ­vel)
- ElevationLevel3 â†” ElevationLevel3 (mesmo nÃ­vel)
- Todos os nÃ­veis â†” Default layer
```

**VisualizaÃ§Ã£o da Matrix:**
```
                    L0   L1   L2   L3   Default
ElevationLevel0  â”‚  âœ…   âŒ   âŒ   âŒ     âœ…
ElevationLevel1  â”‚  âŒ   âœ…   âŒ   âŒ     âœ…
ElevationLevel2  â”‚  âŒ   âŒ   âœ…   âŒ     âœ…
ElevationLevel3  â”‚  âŒ   âŒ   âŒ   âœ…     âœ…
Default          â”‚  âœ…   âœ…   âœ…   âœ…     âœ…
```

### 5.4 Criar Tilemaps para Cada NÃ­vel

**Estrutura de GameObjects Recomendada:**

```
Scene Hierarchy:
â””â”€â”€ Grid
    â”œâ”€â”€ Level0_Ground (Tilemap)
    â”‚   â”œâ”€â”€ TilemapRenderer: Sorting Layer = "Level0Ground"
    â”‚   â””â”€â”€ TilemapCollider2D: Layer = "ElevationLevel0"
    â”‚
    â”œâ”€â”€ Level1_Mountain (Tilemap)
    â”‚   â”œâ”€â”€ TilemapRenderer: Sorting Layer = "Level1Ground"
    â”‚   â””â”€â”€ TilemapCollider2D: Layer = "ElevationLevel1"
    â”‚
    â”œâ”€â”€ Level2_Bridge (Tilemap)
    â”‚   â”œâ”€â”€ TilemapRenderer: Sorting Layer = "Level2Ground"
    â”‚   â””â”€â”€ TilemapCollider2D: Layer = "ElevationLevel2"
    â”‚
    â””â”€â”€ Level3_Rooftop (Tilemap)
        â”œâ”€â”€ TilemapRenderer: Sorting Layer = "Level3Ground"
        â””â”€â”€ TilemapCollider2D: Layer = "ElevationLevel3"
```

**Passo-a-passo para criar um Tilemap:**

1. **Criar GameObject:**
   - Right-click em Grid â†’ `2D Object â†’ Tilemap â†’ Rectangular`
   - Renomear para `Level0_Ground`

2. **Configurar TilemapRenderer:**
   - Selecionar GameObject
   - Inspector â†’ Tilemap Renderer:
     - Sorting Layer: `Level0Ground`
     - Order in Layer: `0`

3. **Adicionar TilemapCollider2D:**
   - Inspector â†’ `Add Component â†’ Tilemap Collider 2D`

4. **Configurar Layer do GameObject:**
   - Inspector â†’ Layer dropdown (topo): `ElevationLevel0`

5. **Repetir para todos os 4 nÃ­veis**

### 5.5 Criar Prefab de Escada

**Estrutura:**

```
StairsPrefab
â”œâ”€â”€ SpriteRenderer (visual da escada)
â”œâ”€â”€ BoxCollider2D (IsTrigger = true)
â””â”€â”€ ElevationZone.cs
```

**Passo-a-passo:**

1. **Criar GameObject vazio:**
   - Hierarchy â†’ Right-click â†’ `Create Empty`
   - Renomear para `Stairs_Level0to1`

2. **Adicionar Sprite:**
   - Add Component â†’ Sprite Renderer
   - Sprite: (sua sprite de escada)
   - Sorting Layer: `Level0Ground`
   - Order in Layer: `500` (na frente do chÃ£o)

3. **Adicionar Collider:**
   - Add Component â†’ Box Collider 2D
   - âœ… Marcar "Is Trigger"
   - Ajustar size para cobrir Ã¡rea da escada

4. **Adicionar Script:**
   - Add Component â†’ Elevation Zone
   - Configure:
     - Target Level: `Platform` (Level 1)
     - Required Source Level: `0` (Ground)
     - Direction: `Up`

5. **Criar Prefab:**
   - Arrastar GameObject para `Assets/Prefabs/Elevation/`

6. **Criar variaÃ§Ã£o para descida:**
   - Duplicar prefab
   - Renomear para `Stairs_Level1to0`
   - Modificar ElevationZone:
     - Target Level: `Ground` (Level 0)
     - Required Source Level: `1` (Platform)
     - Direction: `Down`

### 5.6 Configurar Player

**ModificaÃ§Ãµes no Player Prefab:**

1. **Abrir Player Prefab** em `Assets/Characters/Player/Player.prefab`

2. **Adicionar ElevationEntity:**
   - Inspector â†’ `Add Component â†’ Elevation Entity`
   - Configure:
     - Starting Level: `Ground`
     - Enable Y Sorting: âœ…
     - Show Debug Info: âœ… (para testes)

3. **Ajustar SpriteRenderer:**
   - Sorting Layer: `Level0Entities` (inicial)
   - Order in Layer: deixe 0 (Y-sorting gerencia)

4. **Configurar Layer:**
   - GameObject Layer: `ElevationLevel0` (inicial)

5. **Aplicar mudanÃ§as ao prefab**

### 5.7 Configurar Enemies

**Mesmas modificaÃ§Ãµes para cada Enemy Prefab:**

1. Adicionar `ElevationEntity` component
2. Configurar Starting Level apropriado
3. Ajustar Sorting Layer para o nÃ­vel inicial
4. Configurar GameObject Layer

---

## 6. RenderizaÃ§Ã£o Complexa

### 6.1 Problema: Passar na Frente de Paredes

**CenÃ¡rio:** Player no Level1 deve aparecer NA FRENTE da parede da montanha, mas nÃ£o atravessÃ¡-la.

**SoluÃ§Ã£o 1: Dual Colliders**

```csharp
// MountainWall.cs - Componente para paredes com rendering complexo
using UnityEngine;

public class MountainWall : MonoBehaviour
{
    [Header("Visual")]
    [SerializeField] private SpriteRenderer wallSprite;

    [Header("ColisÃ£o")]
    [SerializeField] private BoxCollider2D topCollider;    // Bloqueia topo
    [SerializeField] private BoxCollider2D bottomCollider; // Bloqueia base

    [Header("ConfiguraÃ§Ã£o")]
    [SerializeField] private float wallHeight = 2f;
    [SerializeField] private ElevationManager.ElevationLevel level = ElevationManager.ElevationLevel.Platform;

    void Awake()
    {
        SetupWall();
    }

    void SetupWall()
    {
        // Configurar sprite (visual completo)
        if (wallSprite == null)
            wallSprite = GetComponent<SpriteRenderer>();

        wallSprite.sortingLayerName = $"Level{(int)level}Ground";
        wallSprite.sortingOrder = 500; // AtrÃ¡s de entities do mesmo nÃ­vel

        // Configurar collider do topo (bloqueia level acima)
        if (topCollider == null)
        {
            topCollider = gameObject.AddComponent<BoxCollider2D>();
        }
        topCollider.size = new Vector2(1f, 0.3f); // Fino
        topCollider.offset = new Vector2(0, wallHeight * 0.4f); // No topo
        topCollider.gameObject.layer = ElevationHelper.LevelToLayer(level);

        // Configurar collider da base (bloqueia level abaixo)
        var bottomObj = new GameObject("BottomCollider");
        bottomObj.transform.parent = transform;
        bottomObj.transform.localPosition = Vector3.zero;

        bottomCollider = bottomObj.AddComponent<BoxCollider2D>();
        bottomCollider.size = new Vector2(1f, 0.3f);
        bottomCollider.offset = new Vector2(0, -wallHeight * 0.4f); // Na base
        bottomCollider.gameObject.layer = ElevationHelper.LevelToLayer(
            (ElevationManager.ElevationLevel)((int)level - 1) // NÃ­vel abaixo
        );
    }

    void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.red;

        // Desenhar collider do topo
        if (topCollider != null)
        {
            Gizmos.DrawWireCube(
                transform.position + (Vector3)topCollider.offset,
                topCollider.size
            );
        }

        // Desenhar collider da base
        if (bottomCollider != null)
        {
            Gizmos.DrawWireCube(
                transform.position + (Vector3)bottomCollider.offset,
                bottomCollider.size
            );
        }
    }
}
```

**Uso:**
1. Criar GameObject com sprite de parede
2. Adicionar `MountainWall.cs`
3. Script cria colliders automaticamente
4. Player renderiza na frente (sorting), mas colide no topo

### 6.2 Problema: Ficar Escondido AtrÃ¡s da Montanha

**CenÃ¡rio:** Player no Level0 passa por trÃ¡s da base da montanha â†’ deve ficar invisÃ­vel imediatamente.

**SoluÃ§Ã£o: Occlusion Zones**

```csharp
// OcclusionZone.cs - Zona de oclusÃ£o dinÃ¢mica
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Cria zona invisÃ­vel atrÃ¡s de estruturas. Entidades que entram
/// ficam atrÃ¡s visualmente (sorting order reduzido).
/// </summary>
[RequireComponent(typeof(BoxCollider2D))]
public class OcclusionZone : MonoBehaviour
{
    [Header("ConfiguraÃ§Ã£o")]
    [Tooltip("Estrutura que oclui (montanha, prÃ©dio, etc)")]
    [SerializeField] private SpriteRenderer occludingStructure;

    [Tooltip("Sorting order para entidades ocluÃ­das")]
    [SerializeField] private int occludedSortingOrder = 100;

    [Header("Debug")]
    [SerializeField] private bool showDebugGizmos = true;
    [SerializeField] private Color gizmoColor = new Color(1f, 0f, 0f, 0.3f);

    private BoxCollider2D triggerZone;
    private Dictionary<SpriteRenderer, int> originalSortingOrders = new();

    void Awake()
    {
        triggerZone = GetComponent<BoxCollider2D>();
        triggerZone.isTrigger = true;

        if (occludingStructure == null)
        {
            occludingStructure = GetComponentInParent<SpriteRenderer>();
        }

        // Calcular occludedSortingOrder automaticamente se nÃ£o configurado
        if (occludedSortingOrder == 100 && occludingStructure != null)
        {
            occludedSortingOrder = occludingStructure.sortingOrder - 1;
        }
    }

    void OnTriggerEnter2D(Collider2D collision)
    {
        // Apenas afetar entidades (Player, Enemies)
        if (!collision.CompareTag("Player") && !collision.CompareTag("Enemy"))
            return;

        var sr = collision.GetComponent<SpriteRenderer>();
        if (sr == null) return;

        // Salvar sorting order original
        if (!originalSortingOrders.ContainsKey(sr))
        {
            originalSortingOrders[sr] = sr.sortingOrder;
        }

        // Aplicar oclusÃ£o (renderizar atrÃ¡s)
        sr.sortingOrder = occludedSortingOrder;

        Debug.Log($"[OcclusionZone] {collision.name} ocluÃ­do (sorting {sr.sortingOrder})");
    }

    void OnTriggerExit2D(Collider2D collision)
    {
        if (!collision.CompareTag("Player") && !collision.CompareTag("Enemy"))
            return;

        var sr = collision.GetComponent<SpriteRenderer>();
        if (sr == null) return;

        // Restaurar sorting order original
        if (originalSortingOrders.TryGetValue(sr, out int originalOrder))
        {
            sr.sortingOrder = originalOrder;
            originalSortingOrders.Remove(sr);

            Debug.Log($"[OcclusionZone] {collision.name} visÃ­vel novamente (sorting {sr.sortingOrder})");
        }
    }

    void OnDrawGizmos()
    {
        if (!showDebugGizmos) return;

        var collider = GetComponent<BoxCollider2D>();
        if (collider == null) return;

        Gizmos.color = gizmoColor;
        Gizmos.DrawCube(transform.position, collider.size);
    }

    void OnDrawGizmosSelected()
    {
        if (!showDebugGizmos) return;

        var collider = GetComponent<BoxCollider2D>();
        if (collider == null) return;

        Gizmos.color = Color.red;
        Gizmos.DrawWireCube(transform.position, collider.size);

        #if UNITY_EDITOR
        UnityEditor.Handles.Label(
            transform.position,
            $"Occlusion Zone\nSorting: {occludedSortingOrder}"
        );
        #endif
    }
}
```

**Setup no Editor:**

1. Criar GameObject filho da montanha: `OcclusionZone_Back`
2. Adicionar `BoxCollider2D` (Is Trigger = true)
3. Posicionar atrÃ¡s da montanha (Ã¡rea onde player deve ficar escondido)
4. Adicionar script `OcclusionZone.cs`
5. Configurar:
   - Occluding Structure: (sprite da montanha)
   - Occluded Sorting Order: (deixar auto ou definir manualmente)

**Resultado:**
- Player entra na zona â†’ sorting order reduz â†’ fica atrÃ¡s da montanha
- Player sai da zona â†’ sorting order restaura â†’ fica visÃ­vel novamente

### 6.3 Exemplo Completo: Montanha com 2 NÃ­veis

**Estrutura de GameObjects:**

```
Mountain_Complex
â”œâ”€â”€ Level0_Base (SpriteRenderer)
â”‚   â”œâ”€â”€ TilemapCollider2D (Layer: ElevationLevel0)
â”‚   â””â”€â”€ OcclusionZone_Back
â”‚       â””â”€â”€ BoxCollider2D (Trigger)
â”‚
â”œâ”€â”€ Level1_Top (SpriteRenderer)
â”‚   â”œâ”€â”€ MountainWall.cs
â”‚   â”œâ”€â”€ TopCollider (BoxCollider2D, Layer: ElevationLevel1)
â”‚   â””â”€â”€ BottomCollider (BoxCollider2D, Layer: ElevationLevel0)
â”‚
â””â”€â”€ Stairs
    â”œâ”€â”€ Stairs_Up (ElevationZone: Level0â†’Level1)
    â””â”€â”€ Stairs_Down (ElevationZone: Level1â†’Level0)
```

**ConfiguraÃ§Ã£o:**

1. **Level0_Base:**
   - Sprite: Base da montanha (chÃ£o)
   - Sorting Layer: `Level0Ground`
   - Sorting Order: 0
   - Layer: `ElevationLevel0`

2. **OcclusionZone_Back:**
   - BoxCollider2D na Ã¡rea "atrÃ¡s" da base
   - OcclusionZone script configurado

3. **Level1_Top:**
   - Sprite: Topo da montanha
   - Sorting Layer: `Level1Ground`
   - Sorting Order: 500
   - MountainWall script (cria colliders automaticamente)

4. **Stairs:**
   - Duas ElevationZones (subida e descida)
   - Posicionadas nas bordas da montanha

**Comportamento Resultante:**

| SituaÃ§Ã£o | Comportamento |
|----------|---------------|
| Player Level0, frente da base | âœ… VisÃ­vel, colide com base |
| Player Level0, atrÃ¡s da base | âŒ Escondido (OcclusionZone), nÃ£o colide |
| Player sobe escada | âœ… Transita para Level1, sorting muda |
| Player Level1, na frente | âœ… VisÃ­vel acima da montanha, colide com topo |
| Enemy Level0, Player Level1 | âŒ NÃ£o interagem (layers diferentes) |

---

## 7. Edge Cases e SoluÃ§Ãµes

### 7.1 MÃºltiplas Entidades em TransiÃ§Ã£o SimultÃ¢nea

**Problema:** 10 enemies sobem escada ao mesmo tempo â†’ performance?

**SoluÃ§Ã£o:** Batching e cooldown

```csharp
// TransitionBatcher.cs - Otimiza mÃºltiplas transiÃ§Ãµes
using UnityEngine;
using System.Collections.Generic;

public class TransitionBatcher : MonoBehaviour
{
    private static TransitionBatcher instance;
    private Queue<System.Action> transitionQueue = new();
    private int transitionsPerFrame = 5;

    void Awake()
    {
        if (instance == null) instance = this;
    }

    void Update()
    {
        // Processar atÃ© N transiÃ§Ãµes por frame
        int processed = 0;
        while (transitionQueue.Count > 0 && processed < transitionsPerFrame)
        {
            transitionQueue.Dequeue()?.Invoke();
            processed++;
        }
    }

    public static void QueueTransition(System.Action transition)
    {
        if (instance != null)
        {
            instance.transitionQueue.Enqueue(transition);
        }
        else
        {
            transition?.Invoke(); // Fallback imediato
        }
    }
}

// Modificar ElevationZone.cs:
private void PerformTransition(GameObject entity)
{
    TransitionBatcher.QueueTransition(() => {
        // ... cÃ³digo de transiÃ§Ã£o existente ...
    });
}
```

### 7.2 ProjÃ©teis/Items Atravessando NÃ­veis

**Problema:** Flecha disparada no Level0 deve acertar enemy no Level1?

**SoluÃ§Ã£o:** Configurar layer do projÃ©til dinamicamente

```csharp
// Projectile.cs
public class Projectile : MonoBehaviour
{
    void Start()
    {
        // Herdar layer de quem disparou
        var shooter = GetComponent<ProjectileData>()?.shooter;
        if (shooter != null)
        {
            gameObject.layer = shooter.layer;

            // Sorting layer tambÃ©m
            var sr = GetComponent<SpriteRenderer>();
            var shooterSR = shooter.GetComponent<SpriteRenderer>();
            if (sr != null && shooterSR != null)
            {
                sr.sortingLayerID = shooterSR.sortingLayerID;
                sr.sortingOrder = shooterSR.sortingOrder + 1;
            }
        }
    }
}
```

**Resultado:** ProjÃ©teis sÃ³ atingem alvos no mesmo nÃ­vel.

### 7.3 Save/Load do Estado de ElevaÃ§Ã£o

**Problema:** Salvar jogo com player no Level2 â†’ carregar â†’ player volta para Level0?

**SoluÃ§Ã£o:** Integrar com sistema de save

```csharp
// Adicionar ao GameManager ou SaveSystem:

[System.Serializable]
public class ElevationSaveData
{
    public int playerElevationLevel;
    public Dictionary<string, int> entityElevations = new();
}

public static void SaveElevationState()
{
    var data = new ElevationSaveData();

    // Salvar player
    var player = GameObject.FindGameObjectWithTag("Player");
    if (player != null)
    {
        data.playerElevationLevel = (int)ElevationManager.GetEntityLevel(player);
    }

    // Salvar enemies/NPCs (opcional)
    var enemies = GameObject.FindGameObjectsWithTag("Enemy");
    foreach (var enemy in enemies)
    {
        string id = enemy.GetInstanceID().ToString();
        data.entityElevations[id] = (int)ElevationManager.GetEntityLevel(enemy);
    }

    // Serializar e salvar
    string json = JsonUtility.ToJson(data);
    PlayerPrefs.SetString("ElevationData", json);
}

public static void LoadElevationState()
{
    string json = PlayerPrefs.GetString("ElevationData", "");
    if (string.IsNullOrEmpty(json)) return;

    var data = JsonUtility.FromJson<ElevationSaveData>(json);

    // Restaurar player
    var player = GameObject.FindGameObjectWithTag("Player");
    if (player != null)
    {
        var level = (ElevationManager.ElevationLevel)data.playerElevationLevel;
        ElevationManager.SetEntityElevation(player, level);
    }

    // Restaurar enemies/NPCs...
}
```

### 7.4 Camera Culling por NÃ­vel

**Problema:** Renderizar todos os 4 nÃ­veis simultaneamente â†’ muitos draw calls.

**SoluÃ§Ã£o:** Culling dinÃ¢mico baseado no nÃ­vel do player

```csharp
// ElevationCameraController.cs
using UnityEngine;

public class ElevationCameraController : MonoBehaviour
{
    [SerializeField] private Camera mainCamera;
    [SerializeField] private GameObject player;
    [SerializeField] private bool enableCulling = true;

    [Header("Visibilidade")]
    [Tooltip("Renderizar N nÃ­veis acima do player")]
    [SerializeField] private int levelsAboveVisible = 1;

    [Tooltip("Renderizar N nÃ­veis abaixo do player")]
    [SerializeField] private int levelsBelowVisible = 0;

    private ElevationManager.ElevationLevel lastPlayerLevel;

    void Awake()
    {
        mainCamera ??= Camera.main;
    }

    void Update()
    {
        if (!enableCulling || player == null) return;

        var currentLevel = ElevationManager.GetEntityLevel(player);

        if (currentLevel != lastPlayerLevel)
        {
            UpdateCameraCulling(currentLevel);
            lastPlayerLevel = currentLevel;
        }
    }

    private void UpdateCameraCulling(ElevationManager.ElevationLevel playerLevel)
    {
        int playerLevelInt = (int)playerLevel;

        // Calcular quais layers devem ser visÃ­veis
        int visibleMask = 0;

        for (int i = playerLevelInt - levelsBelowVisible;
             i <= playerLevelInt + levelsAboveVisible;
             i++)
        {
            if (i < 0 || i > 3) continue; // Validar range [0-3]

            // Adicionar layer ao mask
            int layerID = ElevationHelper.LevelToLayer((ElevationManager.ElevationLevel)i);
            visibleMask |= (1 << layerID);
        }

        // Sempre renderizar Default, UI, etc
        visibleMask |= (1 << LayerMask.NameToLayer("Default"));
        visibleMask |= (1 << LayerMask.NameToLayer("UI"));

        // Aplicar culling mask
        mainCamera.cullingMask = visibleMask;

        Debug.Log($"[CameraController] Player em Level{playerLevelInt}, culling atualizado: {Convert.ToString(visibleMask, 2)}");
    }
}
```

**Resultado:** Performance melhorada, apenas nÃ­veis relevantes renderizados.

### 7.5 Audio/VFX EspecÃ­ficos por Altura

**Problema:** Passos devem soar diferente em nÃ­veis diferentes.

**SoluÃ§Ã£o:** Audio zones por elevaÃ§Ã£o

```csharp
// ElevationAudioManager.cs
using UnityEngine;

public class ElevationAudioManager : MonoBehaviour
{
    [System.Serializable]
    public class LevelAudio
    {
        public ElevationManager.ElevationLevel level;
        public AudioClip[] footstepSounds;
        public AudioClip ambientSound;
        public float ambientVolume = 0.3f;
    }

    [SerializeField] private LevelAudio[] levelAudios;
    [SerializeField] private AudioSource footstepSource;
    [SerializeField] private AudioSource ambientSource;

    private void Start()
    {
        // Subscrever a eventos de elevaÃ§Ã£o
        ElevationManager.OnElevationChanged += OnPlayerElevationChanged;
    }

    private void OnPlayerElevationChanged(GameObject entity, ElevationManager.ElevationLevel newLevel)
    {
        if (!entity.CompareTag("Player")) return;

        // Encontrar config de Ã¡udio para este nÃ­vel
        var audioConfig = System.Array.Find(levelAudios, a => a.level == newLevel);
        if (audioConfig == null) return;

        // Atualizar som ambiente
        if (ambientSource != null && audioConfig.ambientSound != null)
        {
            ambientSource.clip = audioConfig.ambientSound;
            ambientSource.volume = audioConfig.ambientVolume;
            ambientSource.loop = true;
            ambientSource.Play();
        }

        Debug.Log($"[AudioManager] Ãudio mudado para Level {newLevel}");
    }

    public void PlayFootstep(ElevationManager.ElevationLevel level)
    {
        var audioConfig = System.Array.Find(levelAudios, a => a.level == level);
        if (audioConfig == null || audioConfig.footstepSounds.Length == 0) return;

        // Tocar som aleatÃ³rio de passos
        var clip = audioConfig.footstepSounds[Random.Range(0, audioConfig.footstepSounds.Length)];
        footstepSource?.PlayOneShot(clip);
    }
}
```

### 7.6 Pathfinding Entre NÃ­veis

**Problema:** Enemy precisa encontrar caminho do Level0 â†’ Level2 usando escadas.

**SoluÃ§Ã£o:** Navmesh customizado ou waypoints

```csharp
// ElevationPathfinding.cs - Sistema simplificado
using UnityEngine;
using System.Collections.Generic;

public class ElevationPathfinding : MonoBehaviour
{
    [System.Serializable]
    public class ElevationConnection
    {
        public Transform point;
        public ElevationManager.ElevationLevel level;
    }

    [SerializeField] private List<ElevationConnection> connections = new();

    public List<Vector3> FindPath(
        Vector3 start,
        ElevationManager.ElevationLevel startLevel,
        Vector3 goal,
        ElevationManager.ElevationLevel goalLevel
    )
    {
        var path = new List<Vector3>();

        // Mesmo nÃ­vel: caminho direto
        if (startLevel == goalLevel)
        {
            path.Add(start);
            path.Add(goal);
            return path;
        }

        // NÃ­veis diferentes: encontrar escadas intermediÃ¡rias
        // (simplificado - em produÃ§Ã£o use A* ou similar)

        // 1. Ir para escada mais prÃ³xima
        var nearestStair = FindNearestStair(start, startLevel);
        if (nearestStair != null)
        {
            path.Add(start);
            path.Add(nearestStair.point.position);
        }

        // 2. Subir/descer nÃ­veis
        int currentLevelInt = (int)startLevel;
        int targetLevelInt = (int)goalLevel;
        int direction = currentLevelInt < targetLevelInt ? 1 : -1;

        while (currentLevelInt != targetLevelInt)
        {
            currentLevelInt += direction;
            var nextLevel = (ElevationManager.ElevationLevel)currentLevelInt;

            var stair = FindStairToLevel(path[path.Count - 1], nextLevel);
            if (stair != null)
            {
                path.Add(stair.point.position);
            }
        }

        // 3. Ir para destino final
        path.Add(goal);

        return path;
    }

    private ElevationConnection FindNearestStair(Vector3 position, ElevationManager.ElevationLevel level)
    {
        float minDist = float.MaxValue;
        ElevationConnection nearest = null;

        foreach (var conn in connections)
        {
            if (conn.level != level) continue;

            float dist = Vector3.Distance(position, conn.point.position);
            if (dist < minDist)
            {
                minDist = dist;
                nearest = conn;
            }
        }

        return nearest;
    }

    private ElevationConnection FindStairToLevel(Vector3 from, ElevationManager.ElevationLevel targetLevel)
    {
        return System.Array.Find(
            connections.ToArray(),
            c => c.level == targetLevel
        );
    }
}
```

---

## 8. MigraÃ§Ã£o do Sistema Atual

### 8.1 AnÃ¡lise do Sistema Antigo

**Arquivo Atual:** `Assets/Scripts/Tilemap/ElevationEntry.cs`

**Problemas Identificados:**
- âŒ Unidirecional (sem exit logic)
- âŒ Desabilita colliders manualmente (ineficiente)
- âŒ Hardcoded sorting order (15)
- âŒ SÃ³ funciona para Player
- âŒ NÃ£o escalÃ¡vel

### 8.2 Plano de MigraÃ§Ã£o

**Fase 1: PreparaÃ§Ã£o (sem breaking changes)**

1. âœ… Criar layers no Project Settings
2. âœ… Configurar Collision Matrix
3. âœ… Adicionar scripts novos (ElevationManager, ElevationZone, ElevationEntity)
4. âœ… Testar em cena separada (Scene2)

**Fase 2: MigraÃ§Ã£o Gradual**

1. Adicionar `ElevationEntity` ao Player:
   ```csharp
   // PlayerController.cs - adicionar em Awake():
   var elevationEntity = gameObject.AddComponent<ElevationEntity>();
   elevationEntity.startingLevel = ElevationManager.ElevationLevel.Ground;
   ```

2. Substituir `ElevationEntry` por `ElevationZone`:
   - Encontrar GameObjects com ElevationEntry
   - Adicionar ElevationZone
   - Configurar target level
   - **NÃ£o remover ElevationEntry ainda** (testar primeiro)

3. Testar transiÃ§Ãµes:
   - Player sobe escada â†’ verifica se muda de layer
   - Player desce escada â†’ verifica se volta
   - Sorting order atualizado corretamente

4. Remover cÃ³digo antigo:
   ```csharp
   // Deletar ou comentar:
   // - ElevationEntry.cs
   // - ReferÃªncias a mountainCollider[]
   ```

**Fase 3: ExpansÃ£o**

1. Adicionar `ElevationEntity` a todos os enemies
2. Modificar `Enemy.cs` com verificaÃ§Ã£o de nÃ­vel
3. Configurar tilemaps com sorting layers corretos
4. Criar prefabs de escadas reutilizÃ¡veis

### 8.3 Checklist de MigraÃ§Ã£o

```
â–¡ Project Settings
  â–¡ Physics Layers criadas (Layer 6-9)
  â–¡ Sorting Layers criadas (10 layers)
  â–¡ Collision Matrix configurada

â–¡ Scripts Novos
  â–¡ ElevationManager.cs adicionado Ã  cena
  â–¡ ElevationZone.cs criado
  â–¡ ElevationEntity.cs criado
  â–¡ ElevationHelper.cs criado (opcional)

â–¡ Player
  â–¡ ElevationEntity component adicionado
  â–¡ Layer inicial configurado (ElevationLevel0)
  â–¡ Sorting layer configurado (Level0Entities)

â–¡ Enemies
  â–¡ ElevationEntity component adicionado a todos
  â–¡ Enemy.cs modificado (CanDetectPlayer)
  â–¡ Sorting layers configuradas

â–¡ Tilemaps
  â–¡ Separados por nÃ­vel (Level0, Level1, etc)
  â–¡ TilemapRenderer com sorting layer correto
  â–¡ TilemapCollider2D com physics layer correto

â–¡ Escadas
  â–¡ ElevationZone substituindo ElevationEntry
  â–¡ Triggers bidirecionais (subir E descer)
  â–¡ Prefabs criados

â–¡ Testes
  â–¡ Player sobe/desce escadas corretamente
  â–¡ Sorting order visual correto
  â–¡ Enemies nÃ£o detectam atravÃ©s de nÃ­veis
  â–¡ ColisÃµes funcionando (mesmo nÃ­vel colide, diferente nÃ£o)

â–¡ Cleanup
  â–¡ ElevationEntry.cs removido
  â–¡ ReferÃªncias antigas deletadas
  â–¡ DocumentaÃ§Ã£o atualizada
```

### 8.4 Script de MigraÃ§Ã£o AutomÃ¡tica

```csharp
#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;

/// <summary>
/// Ferramenta de migraÃ§Ã£o automÃ¡tica do sistema antigo para novo
/// Menu: Tools â†’ Elevation System â†’ Migrate Old System
/// </summary>
public class ElevationMigrationTool : EditorWindow
{
    [MenuItem("Tools/Elevation System/Migrate Old System")]
    public static void ShowWindow()
    {
        GetWindow<ElevationMigrationTool>("Elevation Migration");
    }

    void OnGUI()
    {
        GUILayout.Label("Elevation System Migration", EditorStyles.boldLabel);
        GUILayout.Space(10);

        if (GUILayout.Button("1. Setup Layers (Project Settings)"))
        {
            SetupLayers();
        }

        GUILayout.Space(5);

        if (GUILayout.Button("2. Convert ElevationEntry â†’ ElevationZone"))
        {
            ConvertElevationEntries();
        }

        GUILayout.Space(5);

        if (GUILayout.Button("3. Add ElevationEntity to Player"))
        {
            AddElevationEntityToPlayer();
        }

        GUILayout.Space(5);

        if (GUILayout.Button("4. Add ElevationEntity to Enemies"))
        {
            AddElevationEntityToEnemies();
        }

        GUILayout.Space(20);

        if (GUILayout.Button("RUN ALL (Full Migration)", GUILayout.Height(40)))
        {
            if (EditorUtility.DisplayDialog(
                "Full Migration",
                "Isso irÃ¡ migrar todo o sistema. Certifique-se de ter backup!\n\nContinuar?",
                "Sim", "Cancelar"))
            {
                SetupLayers();
                ConvertElevationEntries();
                AddElevationEntityToPlayer();
                AddElevationEntityToEnemies();

                EditorUtility.DisplayDialog("ConcluÃ­do", "MigraÃ§Ã£o completa!", "OK");
            }
        }
    }

    private void SetupLayers()
    {
        Debug.Log("[Migration] Configurando layers...");

        // Nota: Layers nÃ£o podem ser adicionadas programaticamente facilmente
        // Esta funÃ§Ã£o apenas valida se jÃ¡ existem

        bool valid = true;

        if (LayerMask.NameToLayer("ElevationLevel0") == -1)
        {
            Debug.LogError("Layer 'ElevationLevel0' nÃ£o encontrada! Adicione manualmente no Layer 6.");
            valid = false;
        }

        if (LayerMask.NameToLayer("ElevationLevel1") == -1)
        {
            Debug.LogError("Layer 'ElevationLevel1' nÃ£o encontrada! Adicione manualmente no Layer 7.");
            valid = false;
        }

        if (valid)
        {
            Debug.Log("[Migration] âœ… Layers validadas com sucesso!");
        }
    }

    private void ConvertElevationEntries()
    {
        Debug.Log("[Migration] Convertendo ElevationEntry â†’ ElevationZone...");

        var oldEntries = FindObjectsByType<ElevationEntry>(FindObjectsSortMode.None);
        int converted = 0;

        foreach (var oldEntry in oldEntries)
        {
            var go = oldEntry.gameObject;

            // Adicionar novo componente
            var newZone = go.AddComponent<ElevationZone>();

            // Configurar (valores padrÃ£o)
            newZone.targetLevel = ElevationManager.ElevationLevel.Platform;
            newZone.direction = ElevationZone.TransitionDirection.Up;

            // Marcar old entry para remoÃ§Ã£o manual
            Debug.LogWarning($"[Migration] {go.name}: ElevationZone adicionado. Remova ElevationEntry manualmente apÃ³s testar.");

            converted++;
        }

        Debug.Log($"[Migration] âœ… {converted} ElevationEntry(s) convertidos!");
    }

    private void AddElevationEntityToPlayer()
    {
        Debug.Log("[Migration] Adicionando ElevationEntity ao Player...");

        var player = GameObject.FindGameObjectWithTag("Player");
        if (player == null)
        {
            Debug.LogError("[Migration] Player nÃ£o encontrado!");
            return;
        }

        if (player.GetComponent<ElevationEntity>() != null)
        {
            Debug.LogWarning("[Migration] Player jÃ¡ tem ElevationEntity!");
            return;
        }

        var entity = player.AddComponent<ElevationEntity>();
        entity.startingLevel = ElevationManager.ElevationLevel.Ground;
        entity.enableYSorting = true;

        Debug.Log("[Migration] âœ… ElevationEntity adicionado ao Player!");
    }

    private void AddElevationEntityToEnemies()
    {
        Debug.Log("[Migration] Adicionando ElevationEntity aos Enemies...");

        var enemies = GameObject.FindGameObjectsWithTag("Enemy");
        int added = 0;

        foreach (var enemy in enemies)
        {
            if (enemy.GetComponent<ElevationEntity>() != null)
                continue;

            var entity = enemy.AddComponent<ElevationEntity>();
            entity.startingLevel = ElevationManager.ElevationLevel.Ground;
            entity.enableYSorting = true;

            added++;
        }

        Debug.Log($"[Migration] âœ… ElevationEntity adicionado a {added} enemy(ies)!");
    }
}
#endif
```

---

## 9. Performance e OtimizaÃ§Ã£o

### 9.1 Benchmarks

**Sistema Antigo (ElevationEntry.cs):**
- Custo por transiÃ§Ã£o: ~0.5ms
- Enable/Disable colliders: custoso
- LimitaÃ§Ã£o: ~10 transiÃ§Ãµes/frame

**Sistema Novo (Layers):**
- Custo por transiÃ§Ã£o: ~0.1ms
- MudanÃ§a de layer: instantÃ¢nea
- LimitaÃ§Ã£o: ~50+ transiÃ§Ãµes/frame

### 9.2 OtimizaÃ§Ãµes Aplicadas

1. **Collision Matrix:** Unity usa hardware para filtrar colisÃµes
2. **Sorting Layers:** RenderizaÃ§Ã£o otimizada pelo engine
3. **Y-Sorting:** Cache de sorting order (nÃ£o recalcula todo frame)
4. **Event System:** Subscribers sÃ³ chamados quando necessÃ¡rio

### 9.3 Profiling

```csharp
// ElevationProfiler.cs - Ferramenta de debug de performance
using UnityEngine;
using UnityEngine.Profiling;

public class ElevationProfiler : MonoBehaviour
{
    [Header("Stats")]
    [SerializeField] private bool showStats = true;

    private int transitionsThisFrame = 0;
    private int totalTransitions = 0;
    private float avgTransitionTime = 0f;

    void OnEnable()
    {
        ElevationManager.OnElevationChanged += OnTransition;
    }

    void OnDisable()
    {
        ElevationManager.OnElevationChanged -= OnTransition;
    }

    void OnTransition(GameObject entity, ElevationManager.ElevationLevel level)
    {
        Profiler.BeginSample("Elevation Transition");
        transitionsThisFrame++;
        totalTransitions++;
        Profiler.EndSample();
    }

    void LateUpdate()
    {
        if (transitionsThisFrame > 10)
        {
            Debug.LogWarning($"[Profiler] {transitionsThisFrame} transiÃ§Ãµes em um frame! Considere batching.");
        }

        transitionsThisFrame = 0;
    }

    void OnGUI()
    {
        if (!showStats) return;

        GUI.Box(new Rect(10, 10, 300, 100), "Elevation Profiler");
        GUI.Label(new Rect(20, 35, 280, 20), $"Total Transitions: {totalTransitions}");
        GUI.Label(new Rect(20, 55, 280, 20), $"This Frame: {transitionsThisFrame}");
        GUI.Label(new Rect(20, 75, 280, 20), $"Avg Time: {avgTransitionTime:F2}ms");
    }
}
```

---

## 10. ReferÃªncias

### 10.1 DocumentaÃ§Ã£o Unity Oficial

- [Physics 2D Settings](https://docs.unity3d.com/Manual/class-Physics2DManager.html)
- [Sorting Layers](https://docs.unity3d.com/Manual/class-TagManager.html#SortingLayers)
- [Layer-based Collision Detection](https://docs.unity3d.com/Manual/LayerBasedCollision.html)
- [2D Sorting](https://docs.unity3d.com/Manual/2DSorting.html)

### 10.2 Assets Relacionados

**Neste Projeto:**
- `/Assets/Scripts/Tilemap/ElevationEntry.cs` (sistema antigo)
- `/Assets/Scenes/Scene2.unity` (exemplo de elevaÃ§Ã£o)
- `/Assets/Art/Tiny Swords (Update 010)/Terrain/` (art assets)

### 10.3 Artigos Recomendados

- [Zelda-Style Elevation in 2D](https://www.gamedeveloper.com/design/implementing-elevation-in-2d-games) (conceito)
- [Unity Layer Best Practices](https://unity.com/how-to/organizing-your-project-layers-and-tags) (organizaÃ§Ã£o)
- [2D Sorting Techniques](https://blog.unity.com/engine-platform/sprite-sorting-techniques-in-unity) (rendering)

### 10.4 Troubleshooting

**Problema:** Player nÃ£o colide com nada apÃ³s transiÃ§Ã£o
- **SoluÃ§Ã£o:** Verificar se Collision Matrix estÃ¡ configurada corretamente
- **Debug:** `ElevationHelper.DebugElevationInfo(playerObject)`

**Problema:** Sorting order incorreto
- **SoluÃ§Ã£o:** Verificar range de sorting orders (0-999 dentro de cada level)
- **Debug:** Ativar `showDebugInfo` em ElevationEntity

**Problema:** Performance ruim com muitos NPCs
- **SoluÃ§Ã£o:** Ativar `TransitionBatcher` e aumentar cooldown
- **Debug:** Usar `ElevationProfiler` para monitorar transiÃ§Ãµes

---

## ConclusÃ£o

Este sistema de elevaÃ§Ã£o multi-nÃ­veis usando **Layers do Unity** Ã© uma soluÃ§Ã£o:

âœ… **EscalÃ¡vel** - Suporta 4+ nÃ­veis facilmente
âœ… **PerformÃ¡tica** - Unity gerencia colisÃµes via hardware
âœ… **FlexÃ­vel** - Funciona com Player, Enemies, NPCs, Projectiles
âœ… **Integrada** - Compatible com sistemas existentes (Inventory, Health, etc)
âœ… **Robusta** - Bidirecional, com state management e eventos

**PrÃ³ximos Passos:**
1. Implementar scripts (seÃ§Ã£o 4)
2. Configurar Unity Editor (seÃ§Ã£o 5)
3. Testar casos de uso (seÃ§Ã£o 3)
4. Migrar sistema antigo (seÃ§Ã£o 8)

**Tempo Estimado de ImplementaÃ§Ã£o:** 4-6 horas para desenvolvedor experiente.

---

**DÃºvidas?** Consulte o troubleshooting (seÃ§Ã£o 10.4) ou ative debug mode em todos os scripts.

**ContribuiÃ§Ãµes:** Este sistema estÃ¡ pronto para expansÃ£o. Considere adicionar:
- Sistema de sombras dinÃ¢micas por nÃ­vel
- Parallax scrolling baseado em elevaÃ§Ã£o
- Weather effects especÃ­ficos por altura
- Flying entities (layer intermediÃ¡rio entre nÃ­veis)

---

*DocumentaÃ§Ã£o criada em 2025-11-13*
*Para: TopDown2D Crash Course*
*Por: Engenharia SÃªnior Unity 2D*
